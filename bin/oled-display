#!/usr/bin/env python

import sys
import time
import json
import threading
from Queue import Queue
from collections import deque
from monotonic import time as mt

from rpjios import Util
from rpjios.SubscriberBase import PSubscriber

import Adafruit_GPIO.SPI as SPI
import Adafruit_SSD1306

from PIL import Image
from PIL import ImageDraw
from PIL import ImageFont

import subprocess
from subprocess import Popen, PIPE
from datetime import timedelta

DEFAULT_GPIO_RESET_PIN = 24

class OLEDScreen(object):
    def __init__(self, reset_pin=DEFAULT_GPIO_RESET_PIN):
        self._disp = Adafruit_SSD1306.SSD1306_128_32(rst=reset_pin)
        self._disp.begin()
        self.clear()
        self._img = Image.new('1', (self._disp.width, self._disp.height))
        self._draw = ImageDraw.Draw(self._img)
        self._font = ImageFont.load_default()

    @property
    def width(self):
        return self._disp.width

    @property
    def height(self):
        return self._disp.height

    @property
    def font(self):
        return self._font

    def clear(self):
        self._disp.clear()
        self._disp.display()

    def draw(self):
        return self._draw

    def render(self):
        self._disp.image(self._img)
        self._disp.display()

class OLEDSubscriber(object):
    def __init__(self):
        self._hn = Util.hostname()
        self._q = Queue()
        self._counts = {'hosts':{},'total':0}
        self._stats = {'mps':deque(maxlen=10)}
        self._run = True
        self._psub = PSubscriber("*").add_listener(lambda x: self._q.put(x))

        self._statthread = threading.Thread(target=self._statthreadfunc)
        self._statthread.daemon = True
        self._subthread = threading.Thread(target=self._subthreadfunc)
        self._subthread.daemon = True

        self._statthread.start()
        self._subthread.start()

    def __del__(self):
        self._run = False
        self._subthread.join()
        self._statthreadfunc.join()

    @property
    def statistics(self):
        mpsl = list(self._stats['mps'])
        return {'messages_per_second': float(sum(mpsl)) / float(len(mpsl)), 'counts': self._counts}

    def _statthreadfunc(self):
        _lc = 0
        while self._run:
            _s = mt.time()
            _cc = self._counts['total']
            if _cc > 0:
                self._stats['mps'].append(_cc - _lc)
                _lc = _cc
            time.sleep(1.0 - (mt.time() - _s))

    def _subthreadfunc(self):
        while self._run:
            msg = self._q.get()
            (host, mtype, ename) = msg["channel"].split(':')
            print "{} {} {}".format(host, mtype, ename)

            self._counts['hosts'][host] = 0 if host not in self._counts['hosts'] else (self._counts['hosts'][host] + 1)
            self._counts['total'] += 1

def uptime():
    with open('/proc/uptime', 'r') as f:
        uptime_seconds = int(float(f.readline().split()[0]))
        uptime_string = str(timedelta(seconds = uptime_seconds))
        if (uptime_seconds < 10*60*60):
            uptime_string = '0'+uptime_string
    return uptime_string

if __name__ == '__main__':
    d = {}
    os = OLEDScreen()
    osd = os.draw()

    x = 0
    top = -2
    lastMark = mt.time()
    tchar = ':'

    ols = OLEDSubscriber()

    while 1:
        osd.rectangle((0,0,os.width,os.height), outline=0, fill=0)

        L1 = 'No network data' if 'NetInfo' not in d else "{} {}".format(d['NetInfo']['interfaces']['wlan0']['addr'], d['NetInfo']['interfaces']['wlan0']['ssid'])
        L2 = 'Soil: {:.0f}'.format(d['Soil']) if 'Soil' in d else "No soil data"
        #L2 = "{:.1f}F AMB, {:.0f}F CPU".format(d['BME680']['temperature'], d['SysInfo']['cpuF']) if 'BME680' in d and 'SysInfo' in d else "No temperature data"
        #L3 = 'No environmental data' if not ('BME680' in d and 'Soil' in d) else 'VOC: {:.0f}K  Soil: {:.0f}'.format(d['BME680']['gas_resistance'] / 1000.0, d['Soil'])
        #L3 = 'No environmental data' if not 'BME680' in d else 'AQ,BP: {:.0f}K, {:.1f}'.format(d['BME680']['gas_resistance'] / 1000.0, d['BME680']['pressure'])
        L3 = ""

        tm = mt.localtime()
        cm = mt.time()
        if (cm - lastMark) > 1.0:
            tchar = ' ' if tchar is ':' else ':'
            lastMark = cm
        L4 = "[{:02d}{}{:02d}{}{:02d}]   {}".format((tm.tm_hour%12), tchar, tm.tm_min, tchar, tm.tm_sec, "/: " +
         ("{:.1f}%".format(100.0 - d['SysInfo']['fsFree%']['/']) if 'SysInfo' in d else '??.?%'))#uptime())

    
        osd.text((x, top), str(L1).strip(), font=os.font, fill=255)
        osd.text((x, top+8), str(L2), font=os.font, fill=255)
        osd.text((x, top+16), str(L3), font=os.font, fill=255)
        osd.text((x, top+24), str(L4), font=os.font, fill=255)

        os.render()

        time.sleep(0.95)
        print "STATS!  {}".format(ols.statistics)

    for s in subs:
        del s
